#!/bin/sh /etc/rc.common

. "/lib/functions/network.sh"

USE_PROCD=1
START=99

CONF="clash"
CONF_DIR="/etc/clash"
BUILD_CONF_SCRIPT="/usr/lib/clash/build_conf.lua"
DNSMASQ_RULE_FILE="/tmp/dnsmasq.d/clash.conf"

CREATE_FIREWALL_RULE_SCRIPT="/usr/share/clash/create_firewall_rules.sh"
CLEAR_FIREWALL_RULE_SCRIPT="/usr/share/clash/clear_firewall_rules.sh"

msg() {
	logger -p daemon.info -st "$CONF[$$]" "$*"
}

restart_other_service() {
	local service=$1
	/etc/init.d/$service restart >/dev/null 2>&1
}

start_clash() {
	config_load "$CONF"

	local conffile="$CONF_DIR/config.yaml"
	local prog
	local api_port
	local api_host

	config_get prog "global" "prog" "/usr/bin/clash"
	config_get api_host "global" "api_host"
	config_get api_port "global" "api_port"

	$BUILD_CONF_SCRIPT

	procd_open_instance
	procd_set_param command "$prog"
	[ -d "$CONF_DIR" ] || mkdir "$CONF_DIR"
	chown -R "$user" "$CONF_DIR" 2>/dev/null
	procd_append_param command -d "$CONF_DIR"
	procd_set_param file "$conffile"
	procd_set_param stdout 1
	procd_set_param stderr 1
	procd_set_param respawn

	procd_close_instance
}

enable_firewall_rules() {
	msg "Appling firewall rules"
	$CREATE_FIREWALL_RULE_SCRIPT
}

disable_firewall_rules() {
	msg "Removing firewall rules"
	$CLEAR_FIREWALL_RULE_SCRIPT
}

create_routing_rule() {
	msg "Appling route rules"
	local tproxy_mark="$1"
	ip rule add fwmark "$tproxy_mark" table 100 2>/dev/null
	ip route add local 0.0.0.0/0 dev lo table 100 2>/dev/null
}

clear_routing_rule() {
	msg "Removing route rules"
	local tproxy_mark="$1"
	ip rule del fwmark "$tproxy_mark" table 100 2>/dev/null
	ip route del local 0.0.0.0/0 dev lo table 100 2>/dev/null
}

create_dnsmasq_rule() {
	msg "Appling dnsmasq rules and restarting dnsmasq service"
	local dns_host="$1"
	local dns_port="$2"
	echo "strict-order" >$DNSMASQ_RULE_FILE
	echo "server=$dns_host#$dns_port" >>$DNSMASQ_RULE_FILE
	restart_other_service "dnsmasq"
}

clear_dnsmasq_rule() {
	msg "Removing dnsmasq rules and restarting dnsmasq service"
	rm -f $DNSMASQ_RULE_FILE
	restart_other_service "dnsmasq"
}

start_service() {
	config_load "$CONF"

	local enabled
	local dns_host dns_port
	local tproxy_enabled tporxy_mark

	config_get_bool enabled "global" "enabled" "0"
	config_get_bool tproxy_enabled "global" "tproxy_enabled"
	config_get tproxy_mark "global" "tproxy_mark" "1"
	config_get dns_host "global" "dns_host"
	config_get dns_port "global" "dns_port"

	clear_routing_rule "$tproxy_mark"

	[ "$enabled" -eq "1" ] || {
		msg "Instance is disabled"
		return 0
	}

	start_clash

	if [ "$tproxy_enabled" -eq 1 ]; then
		msg "Transparent proxy is enabled"
		create_routing_rule "$tproxy_mark"
		enable_firewall_rules
		create_dnsmasq_rule "$dns_host" "$dns_port"
	fi
}

stop_service() {
	config_load "$CONF"
	config_get tproxy_mark "global" "tproxy_mark" "1"

	clear_routing_rule "$tproxy_mark"
	disable_firewall_rules
	clear_dnsmasq_rule
}

reload_service() {
	stop
	start
}

service_triggers() {
	config_load $CONF

	local iface trigger_delay
	config_get trigger_delay "global" "trigger_delay"
	PROCD_RELOAD_DELAY=$((trigger_delay * 1000))
	network_find_wan iface
	if [ -n "$iface" ]; then
		procd_add_interface_trigger "interface.*" $iface "/etc/init.d/clash" "restart"
	fi
	procd_add_reload_trigger "$CONF"
}
